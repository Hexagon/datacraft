class DataSet{constructor(entries){this.entries=[];if(entries)this.insert(entries)}insert(inData){if(Array.isArray(inData)){inData.forEach(v=>{this.entries.push(v)})}else{throw new TypeError("DataSet: Parameter to insert must be an array.")}}drop(fieldName){this.entries.forEach(e=>delete e[fieldName]);return this}join(oDs,target,conditionCb){this.entries.forEach(localObj=>{const matches=[];oDs.entries.forEach(remoteObj=>{if(conditionCb(localObj,remoteObj)){matches.push(remoteObj)}});localObj[target]=matches});return this}joinFirst(oDs,target,conditionCb){this.entries.forEach(localObj=>{oDs.entries.forEach(remoteObj=>{if(conditionCb(localObj,remoteObj)){localObj[target]=remoteObj}})});return this}copy(){return new DataSet(this.entries)}reduce(conditionCb){this.entries=this.filter(conditionCb);return this}filter(conditionCb){return conditionCb?this.entries.filter(conditionCb):this.entries}first(conditionCb){const result=this.filter(conditionCb);return result.length>=1?result[0]:undefined}groupBy(groupByFieldsInput,outputFieldName){let groupByFields=Array.isArray(groupByFieldsInput)?groupByFieldsInput:[groupByFieldsInput],outputMap={},output=[];this.entries.forEach(localObj=>{let currentOutputObj=outputMap;groupByFields.forEach(f=>{let fieldValue=localObj[f]!==undefined?localObj[f]:"undefined";if(currentOutputObj[fieldValue]===undefined){currentOutputObj[fieldValue]={field:f,value:fieldValue,children:{}}}currentOutputObj=currentOutputObj[fieldValue].children});if(Array.isArray(currentOutputObj[outputFieldName])){currentOutputObj[outputFieldName].push(localObj)}else{currentOutputObj[outputFieldName]=[localObj]}});const rebuildResults=(currentLevel,trail)=>{trail=Object.assign({},trail)||{};Object.values(currentLevel).forEach(currentItem=>{if(Array.isArray(currentItem)){trail[outputFieldName]=currentItem;output.push(trail)}else{trail[currentItem.field]=currentItem.value;rebuildResults(currentItem.children,trail)}})};rebuildResults(outputMap);return new DataSet(output)}total(outputFieldName){let newEntry={};newEntry[outputFieldName]=this.entries;return new DataSet([newEntry])}avg(field,outputFieldName,mapCb){this.entries.forEach(e=>{const data=e[field].map(mapCb);e[outputFieldName]=data.reduce((a,b)=>a+b,0)/data.length});return this}sum(field,outputFieldName,mapCb){this.entries.forEach(e=>{e[outputFieldName]=e[field].map(mapCb).reduce((a,b)=>a+b,0)});return this}min(field,outputFieldName,mapCb){this.entries.forEach(e=>{e[outputFieldName]=Math.min(...e[field].map(mapCb))});return this}max(field,outputFieldName,mapCb){this.entries.forEach(e=>{e[outputFieldName]=Math.max(...e[field].map(mapCb))});return this}countd(field,outputFieldName,mapCb){this.entries.forEach(e=>{const data=e[field].map(mapCb);e[outputFieldName]=new Set(data).size});return this}count(field,outputFieldName,mapCb){this.entries.forEach(e=>{e[outputFieldName]=e[field].map(mapCb).length});return this}calc(outputFieldName,calcCb){this.entries.forEach(e=>{e[outputFieldName]=calcCb(e)});return this}autonumber(outputFieldName){let current=0;this.entries.forEach(e=>{e[outputFieldName]=current++});return this}}export{DataSet,DataSet as default};